/// Plant gene datums - things that build and modify a plant or seed.
/datum/plant_gene
	/// The name of the gene.
	var/name
	/// Flags that determine if a gene can be modified.
	var/mutability_flags

/*
 * Returns the formatted name of the plant gene.
 *
 * Overridden by the various subtypes of plant genes to format their respective names.
 */
/datum/plant_gene/proc/get_name()
	return name

/*
 * Check if the seed can accept this plant gene.
 *
 * our_seed - the seed we're adding the gene to
 *
 * Returns TRUE if the seed can take the gene, and FALSE otherwise.
 */
/datum/plant_gene/proc/can_add(obj/item/seeds/our_seed)
	return !istype(our_seed, /obj/item/seeds/sample) // Samples can't accept new genes.

/// Copies over vars and information about our current gene to a new gene and returns the new instance of gene.
/datum/plant_gene/proc/Copy()
	var/datum/plant_gene/new_gene = new type
	new_gene.mutability_flags = mutability_flags
	return new_gene

/*
 * on_add is called when seed genes are initialized on the /obj/seed.
 */
/datum/plant_gene/proc/on_add(datum/plant_gene_holder/gene_holder)
	return // Not implemented

/*
 * on_remove is called when the gene is removed from a seed.
 */
/datum/plant_gene/proc/on_remove(datum/plant_genes/gene_holder)
	return

/// Reagent genes store a reagent ID and reagent ratio.
/datum/plant_gene/reagent
	name = "UNKNOWN"
	mutability_flags = PLANT_GENE_REMOVABLE
	/// The typepath of the actual reagent that this gene is tied to.
	var/reagent_id = /datum/reagent/consumable/nutriment
	/// The amount of reagent generated by the plant. The equation is [1 + ((max_volume*(potency/100)) * rate)]
	var/rate = 0.04

/datum/plant_gene/reagent/get_name()
	var/formatted_name
	if(!(mutability_flags & PLANT_GENE_REMOVABLE))
		formatted_name += "Fragile "
	formatted_name += "[name] production [rate*100]%"
	return formatted_name

/*
 * Set our reagent's ID and name to the passed reagent.
 *
 * new_reagent_id - typepath of the reagent we're setting this gene to
 */
/datum/plant_gene/reagent/proc/set_reagent(new_reagent_id)
	reagent_id = new_reagent_id

	var/datum/reagent/found_reagent = SSreagents.chemical_reagents_list[new_reagent_id]
	if(found_reagent?.type == reagent_id)
		name = found_reagent.name

/datum/plant_gene/reagent/New(new_reagent_id, new_reagent_rate = 0.04)
	. = ..()
	if(new_reagent_id)
		set_reagent(new_reagent_id)
		rate = new_reagent_rate

/datum/plant_gene/reagent/Copy()
	. = ..()
	var/datum/plant_gene/reagent/new_reagent_gene = .
	new_reagent_gene.name = name
	new_reagent_gene.reagent_id = reagent_id
	new_reagent_gene.rate = rate
	return

/datum/plant_gene/reagent/can_add(obj/item/seeds/our_seed)
	. = ..()
	if(!.)
		return FALSE
	for(var/datum/plant_gene/reagent/seed_reagent in our_seed.genes)
		if(seed_reagent.reagent_id == reagent_id && seed_reagent.rate <= rate)
			return FALSE // We can upgrade reagent genes if our rate is greater than the one already in the plant.
	return TRUE

/**
 * Intends to compare a reagent gene with a set of seeds, and if the seeds contain the same gene, with more production rate, upgrades the rate to the highest of the two.
 *
 * Called when plants are crossbreeding, this looks for two matching reagent_ids, where the rates are greater, in order to upgrade.
 */
/datum/plant_gene/reagent/proc/try_upgrade_gene(obj/item/seeds/seed)
	for(var/datum/plant_gene/reagent/reagent in seed.genes)
		if(reagent.reagent_id != reagent_id || reagent.rate <= rate)
			continue
		rate = reagent.rate
		return TRUE
	return FALSE

/// Traits that affect the grown product.
/datum/plant_gene/trait
	/// The rate at which this trait affects something. This can be anything really - why? I dunno.
	var/rate = 0.05
	/// Bonus lines displayed on examine.
	var/examine_line = ""
	/// Flag - Traits that share an ID cannot be placed on the same plant.
	var/trait_ids
	/// Flag - Modifications made to the final product.
	var/trait_flags
	/// A blacklist of seeds that a trait cannot be attached to.
	var/list/obj/item/seeds/seed_blacklist

/datum/plant_gene/trait/Copy()
	. = ..()
	var/datum/plant_gene/trait/new_trait_gene = .
	new_trait_gene.rate = rate
	return

/*
 * Checks if we can add the trait to the seed in question.
 *
 * source_seed - the seed genes we're adding the trait too
 */
/datum/plant_gene/trait/can_add(obj/item/seeds/source_seed)
	. = ..()
	if(!.)
		return FALSE

	for(var/obj/item/seeds/found_seed as anything in seed_blacklist)
		if(istype(source_seed, found_seed))
			return FALSE

	for(var/datum/plant_gene/trait/trait in source_seed.genes)
		if(trait_ids & trait.trait_ids)
			return FALSE
		if(type == trait.type)
			return FALSE

	return TRUE

/*
 * on_new_plant is called for every plant trait on an /obj/item/grown or /obj/item/food/grown when initialized.
 *
 * our_plant - the source plant being created
 * newloc - the loc of the plant
 */
/datum/plant_gene/trait/proc/on_new_plant(obj/item/our_plant, newloc)
	// Plants should always have seeds, but if a plant gene is somehow being instantiated on a plant with no seed, stop initializing genes
	// (Plants hold their genes on their seeds, so we can't really add them to something that doesn't exist)
	if(isnull(our_plant.get_plant_seed()))
		stack_trace("[our_plant] ([our_plant.type]) has a nulled seed value while trying to initialize [src]!")
		return FALSE

	// Add on any bonus lines on examine
	if(examine_line)
		RegisterSignal(our_plant, COMSIG_PARENT_EXAMINE, PROC_REF(examine))

	return TRUE

/// Add on any unique examine text to the plant's examine text.
/datum/plant_gene/trait/proc/examine(obj/item/our_plant, mob/examiner, list/examine_list)
	SIGNAL_HANDLER

	examine_list += examine_line
